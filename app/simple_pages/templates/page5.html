{% extends "base.html" %}
{% block content %}
    Page 5
    <!doctype html>
    <html lang="en">
    <head>
        <!-- Required meta tags -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <!-- Bootstrap CSS -->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
              integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
              crossorigin="anonymous">

        {% block head %}
            <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}"/>

            <title>{% block title %}{% endblock %}This is {{ name }} Website</title>
        {% endblock %}

    </head>
    <body>
    <h1>Glossary of Terms with Definitions</h1>
    </div>
    <div class="container">
        <div class="row">
            <div class="col-lg-9">
                <p>
                    • Instantiation: Is the act of taking a class and making it into an object. Instantiation allows
                    having multiple calculator classes with their own individual properties such as result. In my code
                    example below, I have instantiated the calculator 1 and 2 by adding parenthesis and storying them
                    in the Calculator class.
                    <br>
                    <br>
                    calc1 = Calculator()
                    <br>
                    calc2 = Calculator()
                    <br>
                    calc1.result = 8
                    <br>
                    calc2.result = 9
                    <br>
                    assert calc1.result == 8
                    <br>
                    assert calc2.result == 9
                    <br>
                </p>
                <p>
                    • Object: Is a self-contained component which consists of methods and properties to make a
                    particular
                    type of data useful. Objects are instances of a class created with specifically defined data.
                    Objects can correspond to real-world objects or an abstract entity. Calculator is an object since
                    you can buy it at a store.
                </p>

                <p>
                    • Class: Classes are user-defined data types that act as the blueprint for individual objects,
                    attributes, and methods. When you group your functions together you put them in a class. Purpose of
                    class is to put related functions together such as creating a subtraction and multiplication
                    classes.
                    <br>
                    <br>
                    class Subtraction:
                    <br>
                    @staticmethod
                    <br>
                    def subtract(value_1, value_2):
                    <br>
                    return value_1 - value_2
                </p>

                <p>• Namespace: It’s like a folder while class is a file. How you cannot have to files names the same in
                    a folder, you cannot have two classes called the same thing in a folder. Order is to have a
                    namespace first and then a class. Namespace is our folder and class are the file. Class being file
                    it has functions inside of it that are the texts that what’s inside the file.
                    <br>
                    <br>
                    Example: _init_.py is our file/class inside the operations namespace/folder.
                </p>

                <p>• Constructor: A constructor method is a special function that creates an instance of the class.
                    Typically, constructor methods accept input arguments to assign the data stored in properties and
                    return an initialized object. Whenever the addition object is created it fires the constructor
                    function. So, when an object or class is instantiated, the first method called automatically is
                    called the constructor:
                    <br>
                    <br>
                    def __init__(self, tuple_list: tuple):
                    <br>
                    Self.values = Calculation.convert_args_to_tuple_of_float(tuple_list)
                </p>

                <p>• Fixture: Fixtures are the functions that will run before and after each test function to which it
                    is applied. They are very important as they help us to set up resources and tear them down before
                    and after the test cases start.
                </p>

                <p>• Type Hint: Type hinting is a formal solution to statically indicate the type of a value within your
                    Python code. In the code example below, type hinting indicates the data type for the values 1 and 2
                    to be a tuple.
                    <br>
                    <br>
                    Tuple(1, 2)
                </p>

                <p>
                    • Type Cast: Type casting refers to changing a variable of one data type into another. For example
                    in the calculator program, changing the sequence/data type List into Tuple is called type casting.
                </p>
                <p>
                    • Unit Testing: involves testing individual components of the software program or
                    application. The main purpose behind this is to check that all the individual parts are
                    working as intended. A unit is known as the smallest possible component of software that
                    can be tested. Generally, it has a few inputs and a single output. In my calculator
                    program, I utilized the pytest, and pylint as unit test methods to test my program.
                    Pytest checks whether the software runs and works. Pylint checks if the code is written
                    to the worldwide standard of the python known as PEP 8.
                </p>
                <p>
                    • Static, Static Method, and Static Property: object are used when have copies of the same thing as
                    you
                    have list of users with a first name and last name. they are all different but the way we send
                    emails is
                    the same no matter to what user. Users are object, sending the email is Static. Statics are like
                    verbs.
                    Although you cannot buy the addition, so it is a static method since you can use it without
                    instantiating. The default in OOP is static since most of the programs we deal with do something and
                    cannot be purchased.
                    To have multiple calculators in our code, we need multiple objects, so we need to instantiate them.
                    A
                    static property or method acts somewhat like a globally accessible function or variable. Simply
                    import
                    the class, and you can read the same value from anywhere else in the program. It's usually not
                    advisable
                    to rely on global variables as they can lead to spaghetti code, but that's not to say that they
                    can't be
                    used.
                </p>
                <p>• Instant Method and Instant Property: Instance are a copy of the class in memory. Instance method
                    are methods or properties that operate on each individual object that is in memory, any time you see
                    self in calculator project its instance method. Means it works on the data that is inside of itself
                    whenever this class is instantiating:
                    i.e. def add(self, value1, value2)
                </p>

                <p>• Encapsulation: It describes the idea of wrapping data and the methods that work on data within one
                    unit. This puts restrictions on accessing variables and methods directly and can prevent the
                    accidental modification of data. To prevent accidental change, an object’s variable can only be
                    changed by an object’s method. In the page OOP, I will explain this concept along with other OOP
                    concepts in details along with code examples.
                </p>
                <p>• Polymorphism: The word polymorphism means having many forms. In programming, polymorphism means the
                    same function name (but different signatures) being used for different types.

                </p>
                <p>• Abstraction: in Python is the process of hiding the real implementation of an application from the
                    user and emphasizing only on how to use the application. Essentially, Abstraction is the concept of
                    object-oriented programming that shows only essential attributes and hides unnecessary information.

                </p>
                <p>
                    • Inheritance: is the capability of one class to derive or inherit the properties from another
                    class.
                    Basically Inheritance is the procedure in which one class inherits the attributes and methods of
                    another class. The class whose properties and methods are inherited is known as the Parent class.

                </p>
                <p>
                    • SOLID: In general, the SOLID principles are basic learning steps for every code developer but are
                    usually ignored
                    by those who does not consider the highest quality of code their absolute priority. To simplify the
                    SOLID concept, it essentially suggests breaking down your code into small pieces, don’t repeat
                    yourself, having each little piece be independent of each other, and assigning each little piece to
                    do everything it needs to perform its action. I will explain SOLID in more details on the SOLID
                    page.

                </p>
                <p>
                    • Design Pattern: A Factory Pattern or Factory Method Pattern says that just define an interface or
                    abstract class for creating an object but let the subclasses decide which class to instantiate. In
                    other words, subclasses are responsible to create the instance of the class. Design method are
                    broken up into three categories: creational patterns, structural patterns, and behavioral patterns.
                    I will explain this in details on the SOLID page.
                    <br>
                    <br>
                </p>
                <h1>Resources:</h1>
                 <p>
                    &#9642;https://docs.python.org/3/library/typing.html
                     <br>
                    &#9642;https://www.w3schools.com/python/python_datatypes.asp
                     <br>
                    &#9642;https://www.geeksforgeeks.org/polymorphism-in-python/?ref=gcse
                </p>

            </div>
            <div class="col-lg-3">
                <img src="static/images/pylint.jpg" width="1500">
            </div>
        </div>
    </div>
    <!-- Optional JavaScript; choose one of the two! -->

    <!-- Option 1: Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
            crossorigin="anonymous"></script>

    <!-- Option 2: Separate Popper and Bootstrap JS -->
    <!--
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous"></script>
    -->
    <script src="{{ url_for('static', filename='js/scripts.js') }}"></script>

    </body>
    </html>
{% endblock %}