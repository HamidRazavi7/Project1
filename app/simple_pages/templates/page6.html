{% extends "base.html" %}
{% block content %}
    Page 6
    <!doctype html>
    <html lang="en">
    <head>
        <!-- Required meta tags -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <!-- Bootstrap CSS -->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
              integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
              crossorigin="anonymous">

        {% block head %}
            <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}"/>

            <title>{% block title %}{% endblock %}This is {{ name }} Website</title>
        {% endblock %}

    </head>
    <body>
    <h1>AAA</h1>
    </div>
    <div class="container">
        <div class="row">
            <div class="col-lg-9">
                <p>
                    When we look at a source code, we should always start with the test. The test would tell us what
                    is happening. When you have a library and want to run the code, you need the test unit to call the
                    functions which run the code. Basically, the program starts at the test. Testing provides important
                    feedback that keeps us safe. By running tests, we ensure our program operates the way it supposed to
                    and informs us of any breaks. It is paramount not to deploy a program that has bugs.
                </p>
                <p>The AAA pattern is simple and provides a uniform structure for all tests in the suite. This uniform
                    structure is one of its biggest advantages: once you get used to this pattern, you can read and
                    understand the tests more easily. That, in turn, reduces the maintenance cost for your entire test
                    suite.
                </p>
                <p>The arrange section is where you set up the objects to be tested. You bring the system under test to
                    a desired state and configure the dependencies: either instantiate them directly or prepare their
                    test doubles. The act section is where you act upon the system under test. You call one of its
                    methods: pass the dependencies and capture the output value if any. The assert section allows you to
                    make the claims about the outcome. This may include the return value, the final state of the SUT and
                    its collaborators, or the methods the SUT called on them.</p>
                <p>
                    To set up my unit test, I followed the two steps below:
                <ol>
                    <li>First create the calculator test as calculator_test.py file, to test the calculation classes.
                        I created this first test to see I can create multiplication, addition, subtraction, and
                        division objects. It does not conduct the operations but ensure it can create the operation
                        methods to create the operation calculations.
                    </li>
                    <li>Once the previous test is proven to run properly, the next step is to create the operations
                        test as an operation_test.py file. I started with the add method and reworked the calculator
                        class to use the calculations and follow the same steps for the other three operations.
                    </li>
                </ol>
                </p>
                <p> I have created a class as a blueprint that holds the code, namespace/folder which is called
                    calculator namespace. By instantiation I take a class and make a copy of class in memory that can
                    have many copies independent of each other which refers to the encapsulation method in OOP. In my
                    calculator program, under the calculator namespace there are two __init__.py files. One is utilized
                    to create and define the calculator class, while the other is used to define my operation classes
                    such as addition,
                <br>
                <br>
                </p>
                <h1>calculator_test.py</h1>
                <p>
                    &#9642;This test is run to check my Calculator class. The Calculator class is defined as an
                    __init__.py
                    file under the calculator namespace.
                    <br>
                    <br>
                </p>
                <p>
                    def test_calculator_is_instance():
                    <br>
                    """Testing the Calculator"""
                    <br>
                    calculator = Calculator()
                    <br>
                    assert isinstance(calculator, Calculator
                    <br>
                    <br>
                    &#9642;The calculator = Calculator() instantiates the calculator class. The instance(calculator,
                    Calculator)
                    checks to see if the calculator is instantiated object of Calculator. It checks to see if this
                    variable contains the Calculator class.
                </p>
                <p>&#9642;The following codes checks the calculator gets our result method, in another words defines
                    how it obtains the result:
                    <br>
                    <br>
                    def test_calculator_get_result_method():
                    <br>
                    """Testing the Calculator"""
                    <br>
                    calculator = Calculator()
                    <br>
                    assert calculator.get_result() == 0
                    <br>
                    <br>
                    &#9642;The following the calculator gets our result method, in another words defines how it obtains
                    the
                    result:
                    <br>
                    <br>
                    def test_calculator_result_property():
                    <br>
                    """Testing the Calculator"""
                    <br>
                    <br>
                    def test_calculator_add_method():
                    <br>
                    """Testing the Calculator"""
                    <br>
                    calculator = Calculator()
                    <br>
                    assert calculator.add(1, 1) == 2
                    <br>
                    <br>
                    &#9642;The lines above define our calculator object and method, once you press and hold
                    command/control key over
                    add, it takes you to the add method as below:
                    <br>
                    <br>
                    def add(self, value_1, value_2):
                    <br>
                    """ This is the add method"""
                    <br>
                    self.result = Addition.add(value_1, value_2)
                    <br>
                    return self.result
                    <br>
                    <br>
                    &#9642;The line above is a static method add to operate the sum operation and return the result
                    property. When you
                    press command and press add, it takes you to the following:
                    <br>
                    <br>
                    def add(value_1, value_2):
                    <br>
                    """ This is the add method"""
                    <br>
                    return value_1 + value_2
                    <br>
                    &#9642;this helps us with define a static method that can be used without instantiating. It creates
                    the
                    sum method when two variables are added.
                    <br>
                <br>
                <h1>operations_test.py</h1>
                <p> &#9642;in this test, all tree arranging, acting, and asserting takes place in one line. Arranging is setting
                    up two variables with values equal to 1. Acting calls the add function to sum the values of the two
                    variables. The assert steps verify the addition of the two variables is equal to 2. This is the
                    preferred method of testing since having only one functions makes testing faster. The same step is
                    used for the remaining operations
                    <br>
                    <br>
                    def test_calculator_operations_add():
                    <br>
                    """Testing the Calculator"""
                    <br>
                    assert Addition.add(1, 1) == 2
                <br>
                    <br>
                </p>
                <h1>Resources:</h1>
                <p>
                    &#9642;https://automationpanda.com/2020/07/07/arrange-act-assert-a-pattern-for-writing-good-tests/
                    <br>
                    &#9642;https://freecontent.manning.com/making-better-unit-tests-part-1-the-aaa-pattern/
                </p>
            </div>
            <div class="col-lg-3">
                <img src="static/images/cd.jpg" width="700">
            </div>
        </div>
    </div>
    <!-- Optional JavaScript; choose one of the two! -->

    <!-- Option 1: Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
            crossorigin="anonymous"></script>

    <!-- Option 2: Separate Popper and Bootstrap JS -->
    <!--
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous"></script>
    -->
    <script src="{{ url_for('static', filename='js/scripts.js') }}"></script>

    </body>
    </html>
{% endblock %}